function [paramsList,optionsList] = config_nonlinParamSys_reach(sys,params,options)
% config_nonlinParamSys_reach - configuration file for validation of
%    model parameters and algorithm parameters
%
% Syntax:
%    [paramsList,optionsList] = config_nonlinParamSys_reach(sys,params,options)
%
% Inputs:
%    sys - nonlinParamSys object
%    params - user-defined model parameters
%    options - user-defined algorithm parameters
%
% Outputs:
%    paramsList - list of model parameters
%    optionsList - list of algorithm parameters
%
% Other m-files required: none
% Subfunctions: none
% MAT-files required: none
%
% See also: none

% Author:       Mark Wetzlinger
% Written:      03-February-2021
% Last update:  ---
% Last revision:19-June-2023 (MW, structs, remove global variables)

%------------- BEGIN CODE --------------

% list of model parameters
paramsList = struct('name',{},'status',{},'checkfun',{},'errmsg',{},'condfun',{});

% append entries to list of model parameters
paramsList(end+1,1) = add2list('R0','mandatory',{@(val)any(ismember(getMembers('R0'),class(val))),@(val)eq(dim(val),sys.dim)},...
    {'memberR0','eqsysdim'});
paramsList(end+1,1) = add2list('U','default',{@(val)any(ismember(getMembers('U'),class(val)))},{'memberU'});
paramsList(end+1,1) = add2list('u','default',{@isnumeric},{'isnumeric'});
paramsList(end+1,1) = add2list('tStart','default',{@isscalar,@(val)ge(val,0)},{'isscalar','gezero'});
paramsList(end+1,1) = add2list('tFinal','mandatory',{@isscalar,@(val)ge(val,params.tStart)},{'isscalar','getStart'});
paramsList(end+1,1) = add2list('paramInt','mandatory',{@(val)length(val)==sys.nrOfParam,...
    @(val)isa(val,'interval') || (isvector(val) && isnumeric(val))},{'eqparam','vectororinterval'});

% list of algorithm parameters
optionsList = struct('name',{},'status',{},'checkfun',{},'errmsg',{},'condfun',{});

% append entries to list of algorithm parameters
optionsList(end+1,1) = add2list('timeStep','mandatory',{@isscalar,@(val)val>0,...
    @(val)abs(params.tFinal/val - round(params.tFinal/val))<1e-9,...
	@(val)c_inputTraj(val,sys,params,options)},...
    {'isscalar','gezero','intsteps',''});
optionsList(end+1,1) = add2list('taylorTerms','mandatory',{@isscalar,@(val)mod(val,1)==0,@(val)ge(val,1)},...
    {'isscalar','integer','geone'});
optionsList(end+1,1) = add2list('intermediateTerms','mandatory',{@isscalar,@isnumeric,...
    @(val)mod(val,1)==0,@(val)ge(val,1),@(val)le(val,options.taylorTerms)},...
    {'isscalar','isnumeric','integer','geone','letaylorTerms'});

optionsList(end+1,1) = add2list('verbose','default',{@isscalar,@islogical},{'isscalar','islogical'});
optionsList(end+1,1) = add2list('saveOrder','optional',{@isscalar,@(val)ge(val,1)},{'isscalar','geone'});

optionsList(end+1,1) = add2list('zonotopeOrder','mandatory',{@isscalar,@(val)ge(val,1)},{'isscalar','geone'});
optionsList(end+1,1) = add2list('reductionTechnique','default',...
    {@ischar,@(val)any(ismember(getMembers('reductionTechnique4nlsys'),val))},...
    {'ischar','memberreductionTechnique4nlsys'});

optionsList(end+1,1) = add2list('compOutputSet','default',{@isscalar,@islogical},...
    {'isscalar','islogical'});

% only dep. factor reachSet options (parameters/options used from AROC)
optionsList(end+1,1) = add2list('approxDepOnly','optional',{@isscalar,@islogical},{'isscalar','islogical'});

optionsList(end+1,1) = add2list('reductionInterval','default',{@isscalar,@(val)ge(val,1),@(val)isinf(val)||mod(val,1)==0},...
    {'isscalar','geone','integerorInf'});
optionsList(end+1,1) = add2list('maxError','default',{@isvector,@(val)all(ge(val,0)),@(val)length(val)==sys.dim},...
    {'isvector','vectorgezero','eqsysdim'});

optionsList(end+1,1) = add2list('alg','mandatory',{@ischar,@(val)any(ismember(getMembers('alg4param'),val)),...
    @(val)c_alg_nonlinParamSys(val,sys,params,options)},{'ischar','memberalg4param',''});
optionsList(end+1,1) = add2list('tensorOrder','mandatory',{@isscalar,@(val)mod(val,1)==0,...
    @(val)c_tensorOrder_nonlinParamSys(val,sys,params,options)},...
	{'isscalar','integer',''});
optionsList(end+1,1) = add2list('tensorOrderOutput','default',...
    {@isscalar,@(val)mod(val,1)==0,@(val)any(val==[2,3])},...
    {'isscalar','integer','2or3'});

optionsList(end+1,1) = add2list('errorOrder','mandatory',{@isscalar,@(val)ge(val,1)},{'isscalar','geone'},{@()options.tensorOrder>2});
optionsList(end+1,1) = add2list('errorOrder3','mandatory',{@isscalar,@(val)ge(val,1)},{'isscalar','geone'},{@()options.tensorOrder>3});
optionsList(end+1,1) = add2list('intermediateOrder','mandatory',{@isscalar,@(val)ge(val,1)},{'isscalar','geone'},{@()options.tensorOrder>2});


% polyZono
optionsList(end+1,1) = add2list('polyZono.maxDepGenOrder','default',{@isscalar,@isnumeric,@(val)ge(val,1)},...
    {'isscalar','isnumeric','geone'},...
    {@()contains(options.alg,'poly')});
optionsList(end+1,1) = add2list('polyZono.maxPolyZonoRatio','default',{@isscalar,@isnumeric,@(val)val>0},...
    {'isscalar','isnumeric','gezero'},...
    {@()contains(options.alg,'poly')});
optionsList(end+1,1) = add2list('polyZono.restructureTechnique','default',{@ischar,...
    @(val)any(ismember(getMembers('restructureTechnique'),val))},...
    {'ischar','memberrestructureTechnique'},...
    {@()contains(options.alg,'poly')});

% lagrangeRem
optionsList(end+1,1) = add2list('lagrangeRem.simplify','default',{@ischar,...
    @(val)any(ismember(getMembers('lagrangeRem.simplify'),val))},...
    {'ischar','memberlagrangeRem.simplify'});
optionsList(end+1,1) = add2list('lagrangeRem.method','default',{@ischar,...
    @(val)any(ismember(getMembers('lagrangeRem.method'),val))},...
    {'ischar','memberlagrangeRem.method'});
optionsList(end+1,1) = add2list('lagrangeRem.tensorParallel','default',{@isscalar,@islogical},{'isscalar','islogical'});
optionsList(end+1,1) = add2list('lagrangeRem.replacements','optional',{@(val)isa(val,'function_handle')},{'isafunction_handle'});
optionsList(end+1,1) = add2list('lagrangeRem.zooMethods','mandatory',...
    {@ischar,@(val)any(ismember(getMembers('lagrangeRem.zooMethods'),val))},...
    {'ischar','memberlagrangeRem.zooMethods'},...
    {@()strcmp(options.lagrangeRem.method,'zoo')});
optionsList(end+1,1) = add2list('lagrangeRem.optMethod','default',...
    {@ischar,@(val)any(ismember(getMembers('lagrangeRem.optMethod'),val))},...
    {'ischar','memberlagrangeRem.optMethod'},...
    {@()strcmp(options.lagrangeRem.method,'taylorModel')});
optionsList(end+1,1) = add2list('lagrangeRem.maxOrder','optional',...
    {@isscalar,@isnumeric,@(val)mod(val,1)==0,@(val)ge(val,1)},...
    {'isscalar','isnumeric','integer','geone'},...
    {@()any(strcmp(options.lagrangeRem.method,{'taylorModel','zoo'}))});
optionsList(end+1,1) = add2list('lagrangeRem.tolerance','optional',{@isscalar,@isnumeric,@(val)ge(val,0)},...
    {'isscalar','isnumeric','gezero'},...
    {@()any(strcmp(options.lagrangeRem.method,{'taylorModel','zoo'}))});
optionsList(end+1,1) = add2list('lagrangeRem.eps','optional',{@isscalar,@isnumeric,@(val)ge(val,0)},...
    {'isscalar','isnumeric','gezero'},...
    {@()any(strcmp(options.lagrangeRem.method,{'taylorModel','zoo'}))});

% used for AROC/reachsetOptimalControl, AROC/polyReachsetOptimalControl
optionsList(end+1,1) = add2list('approxErr','optional',{@islogical},{'islogical'});
optionsList(end+1,1) = add2list('prevErrScale','optional',{@isscalar,@(val) val>=0 && val<=1},{'isscalar','normalized'});
optionsList(end+1,1) = add2list('prevErr','optional',{@(val)isa(val,'zonotope'),@(val)val.dim==sys.dim},{'isazonotope','eqsysdim'});
optionsList(end+1,1) = add2list('updateInitFnc','optional',{@(val)isa(val,'function_handle')},{'isafunction_handle'});
paramsList(end+1,1) = add2list('paramInts','optional',{@(val)size(val,1)==sys.dim,...
    @(val)size(val,2)==reachSteps(params,options)+1},...
    {'eqsysdim','eqreachSteps'});
paramsList(end+1,1) = add2list('refPoints','optional',{@isnumeric,@(val)size(val,1)==sys.dim,...
    @(val)size(val,2)==reachSteps(params,options)+1},...
    {'isnumeric','eqsysdim','eqreachSteps'});

end

%------------- END OF CODE --------------

